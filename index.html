<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="ApproxMVBB : Fast algorithms to compute an approximation of the minimal volume oriented bounding box of a point cloud in 3D.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>ApproxMVBB</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/gabyx/ApproxMVBB">View on GitHub</a>

          <h1 id="project_title">ApproxMVBB</h1>
          <h2 id="project_tagline">Fast algorithms to compute an approximation of the minimal volume oriented bounding box of a point cloud in 3D.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/gabyx/ApproxMVBB/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/gabyx/ApproxMVBB/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1></h1>

<h1>
<a id="approxmvbb" class="anchor" href="#approxmvbb" aria-hidden="true"><span class="octicon octicon-link"></span></a>ApproxMVBB</h1>

<hr>

<h2>
<a id="fast-algorithms-to-compute-an-approximation-of-the-minimal-volume-oriented-bounding-box-of-a-point-cloud-in-3d" class="anchor" href="#fast-algorithms-to-compute-an-approximation-of-the-minimal-volume-oriented-bounding-box-of-a-point-cloud-in-3d" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fast algorithms to compute an approximation of the minimal volume oriented bounding box of a point cloud in 3D.</h2>

<p>Computing the minimal volume oriented bounding box for a given point cloud in 3D is a hard problem in computer science.
Exact algorithms are known and of cubic order in the number of points in 3D. A faster exact algorithm is currently not know. However, for lots of applications an approximation of the minimum volume oriented bounding box is acceptable and already accurate enough.<br>
This small standart compliant C++11 library can either be built into a shared object library 
or directly be included in an existing C++ project. It includes code for computing the ConvexHull in 2D and the minimal area rectangle of a 2D point cloud as well.</p>

<p><img src="https://github.com/gabyx/ApproxMVBB/wiki/images/Bunny.png" alt="alt text" title="Bunny"> <img src="https://github.com/gabyx/ApproxMVBB/wiki/images/Cube.png" alt="alt text" title="Cube"></p>

<hr>

<h2>
<a id="installation--dependencies" class="anchor" href="#installation--dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation &amp; Dependencies</h2>

<p>To build the library, the tests and the example you need the built tool <a href="http://www.cmake.org">cmake</a>.
This library only depends on the matrix library <a href="http://eigen.tuxfamily.org">Eigen</a> at least version 3. Download it and install it on your system.</p>

<p>Download the latest ApproxMVBB code:</p>

<div class="highlight highlight-bash"><pre>    $ git clone https://github.com/gabyx/ApproxMVBB.git ApproxMVBB  </pre></div>

<p>Make a build directory and navigate to it:</p>

<div class="highlight highlight-bash"><pre>    $ mkdir Build
    $ <span class="pl-c1">cd</span> Build</pre></div>

<p>Invoke cmake in the Build directory:</p>

<div class="highlight highlight-bash"><pre>    $ cmake ../ApproxMVBB</pre></div>

<p>The cmake script will find Eigen if you installed it in a system wide folder (e.g <code>/usr/local/</code>)
In the <code>CMakeCache.txt</code> file you can specify what you want to build 
( <code>ApproxMVBB_BUILD_EXAMPLE, ApproxMVBB_BUILD_LIBRARY, ApproxMVBB_BUILD_TESTS</code> )</p>

<p>To install the library and the header files at a specific location <code>/usr/local/include/</code> run cmake with::</p>

<div class="highlight highlight-bash"><pre>    $ cmake -DCMAKE_INSTALL_PREFIX=<span class="pl-s"><span class="pl-pds">"</span>/usr/local/include/<span class="pl-pds">"</span></span> ../ApproxMVBB</pre></div>

<p>Finally, build and install the project:</p>

<div class="highlight highlight-bash"><pre>    $ make all   /<span class="pl-k">*</span> can be ApproxMVBB <span class="pl-k">for</span> <span class="pl-smi">the</span> library or ApproxMVBBExample or ApproxMVBBTests <span class="pl-k">*</span>/
    $ make install</pre></div>

<p>To build in parallel use the <code>-jN</code> flag in the <code>make</code> commmand, where <code>N</code>denotes the number of parallel threads to use.</p>

<p><strong>Cmake Find Scripts</strong><br>
The installation installs also scripts <code>approxmvbb-config.cmake</code> and <code>approxmvbb-config-version.cmake</code> into the <code>lib/cmake</code> folder. To include the library in another project the only thing you need to add in your cmake script is</p>

<div class="highlight highlight-cmake"><pre>    <span class="pl-c1">find_package</span>(ApproxMVBB [version] [Required] )</pre></div>

<p>which defines the following variables if ApproxMVBB has been found successfully:</p>

<div class="highlight highlight-cmake"><pre>    ApproxMVBB_CXX_FLAGS    <span class="pl-c">#- extra flags for compilation</span>
    ApproxMVBB_INCLUDE_DIRS <span class="pl-c">#- include directories</span>
    ApproxMVBB_LIBRARY_REL  <span class="pl-c">#- Release library</span>
    ApproxMVBB_LIBRARY_DGB  <span class="pl-c">#- Debug library</span>
    ApproxMVBB_LIBRARIES    <span class="pl-c">#- libraries to link with</span></pre></div>

<p>If you installed the library into non-system generic location you can set the cmake variable <code>$ApproxMVBB_DIR</code> before invoking the <code>find_library</code> command:</p>

<div class="highlight highlight-cmake"><pre>    <span class="pl-c1">set</span>(ApproxMVBB_DIR <span class="pl-s">"path/to/installation/lib/cmake"</span>)
    <span class="pl-c1">find_package</span>(ApproxMVBB [version] [Required] )</pre></div>

<hr>

<h2>
<a id="supported-platforms" class="anchor" href="#supported-platforms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supported Platforms</h2>

<p>The code has been tested on Linux and OS X with compilers <code>clang</code> and <code>gcc</code>. 
It should work for Windows as well, but has not been tested.</p>

<hr>

<h2>
<a id="example-usage" class="anchor" href="#example-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example Usage</h2>

<p>Please see the <code>example/main.cpp</code> in the source directory.
Given a point cloud with <code>n=10000</code> points sampled in the unit cube in 3D 
we compute an approximation of the minimum volume bounding volume by the following calls:</p>

<div class="highlight highlight-C++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>ApproxMVBB/ComputeApproxMVBB.hpp<span class="pl-pds">"</span></span>

    <span class="pl-k">int</span>  <span class="pl-en">main</span>( <span class="pl-k">int</span>  argc, <span class="pl-k">char</span>  ** argv ){

          ApproxMVBB::Matrix3Dyn <span class="pl-smi">points</span>(<span class="pl-c1">3</span>,<span class="pl-c1">10000</span>);
          points.<span class="pl-c1">setRandom</span>();
          ApproxMVBB::OOBB oobb = <span class="pl-c1">ApproxMVBB::approximateMVBB</span>(points,<span class="pl-c1">0.001</span>,<span class="pl-c1">500</span>,<span class="pl-c1">5</span>,<span class="pl-c1">0</span>,<span class="pl-c1">5</span>);
          oobb.<span class="pl-c1">expandZeroExtent</span>(<span class="pl-c1">0.1</span>);
          <span class="pl-k">return</span> <span class="pl-c1">0</span>;

    }</pre></div>

<p>The returned object oriented bounding box <code>oobb</code> contains the lower <code>oobb.m_minPoint</code> and upper point <code>oobb.m_maxPoint</code> expressed in the coordinate frame K of the bounding box. The bounding box also stores the rotation matrix from the world frame to the object frame K as a quaternion  <code>oobb.m_q_KI</code> . The rotation matrix <code>R_KI</code> from frame I to frame K  can be obtained by <code>oobb.m_q_KI.matrix()</code> (see <code>Eigen::Quaternion</code>). This rotation matrix <code>R_KI</code> corresponds to a coordinate transformation A_IK which transforms coordinates from frame K to coordinates in frame I. Thereforce, to get the lower point expressed in the coordinate frame I this yields:</p>

<div class="highlight highlight-C++"><pre>    ApproxMVBB::Vector3 p = oobb.m_q_KI * oobb.m_minPoint  <span class="pl-c">// A_IK * oobb.m_minPoint </span></pre></div>

<p><strong>Degenerate OOBB:</strong>
The returned bounding box might have a degenerated extent in some axis directions depending on the input points (e.g. 3 points defines a plane which is the minimal oriented bounding box with zero volume). The function <code>expandZeroExtent</code> is a post processing function to enlarge the bounding box by a certain percentage of the largest extent (if exisiting, otherwise a default value is used).</p>

<p><strong>Points Outside of the final OOBB:</strong>
Because the algorithm  works internally with a sample of the point cloud, the resulting OOBB might not contain all points of the original point cloud! To compensate for this an additional loop is required:</p>

<div class="highlight highlight-C++"><pre>    ApproxMVBB::Matrix33 A_KI = oobb.m_q_KI.matrix().transpose();
    <span class="pl-k">auto</span> size = points.cols();
    <span class="pl-k">for</span>( <span class="pl-k">unsigned</span> <span class="pl-k">int</span> i=<span class="pl-c1">0</span>;  i&lt;size; ++i ) {
        oobb.<span class="pl-c1">unite</span>(A_KI*points.<span class="pl-c1">col</span>(i));
    }</pre></div>

<p><strong>Generating a KdTree from the OOBB: (to come!)</strong>
The library will (in the future) include a fast KdTree implementation (which is not claimed to be ultimatively fast and absolutely memory efficient, but was written to fullfill this aspects to a certain level, CGAL and ANN libraries seem faster)
The KdTree splitting heuristic implements a sophisticated splitting optimization and an adaptable quality evaluator which in the most elaborate, performance worst case consists of searching for the best split between the splitting heuristics <code>MIDPOINT</code>,<code>MEDIAN</code> and<code>GEOMETRIC_MEAN</code>  by evaluating a user-provided quality evaluator.</p>

<hr>

<h2>
<a id="function-parameters--how-it-works" class="anchor" href="#function-parameters--how-it-works" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function Parameters &amp; How It Works</h2>

<p>The most important function:</p>

<div class="highlight highlight-C++"><pre>    <span class="pl-en">ApproxMVBB::approximateMVBB</span>(pts, 
                                epsilon, 
                                pointSamples, 
                                gridSize,
                                mvbbDiamOptLoops, 
                                mvbbGridSearchOptLoops)</pre></div>

<p>computes an approximation of the minimal volume bounding box in the following steps:</p>

<ol>
<li>
<strong>An approximation of the diameter</strong> (direction which realizes the diameter: <code>z</code> ) of the points <code>pts</code> is computed. 
The value <code>epsilon</code> is the absolut tolarance for 
the approximation of the diameter and has the same units as the points <code>pts</code> (in the example 0.001 meter)</li>
<li>The points are projected into the plane perpendicular to the direction <code>z</code>
</li>
<li>An approximation of the diameter of the projected points in 2D is computed (direction <code>x</code> )</li>
<li>
<strong>The initial approximate bounding box</strong> <code>A</code> is computed in the orthogonal frame <code>[x,y,z]</code>
</li>
<li>
<strong>A first optional optimization loop</strong> is performed (parameter <code>mvbbDiamOptLoops</code> specifies how many loops) 
by computing the minimal volume bounding box over a direction <code>t</code> where the direction <code>t</code> 
is choosen sequentially from the current optimal bounding box solution. The algorithm starts with the directions of the box <code>A</code>. <em>This optimzation works with all points in <code>pts</code> and might use a lot of time</em>
</li>
<li>
<strong>The initial bounding box</strong> <code>A</code> is used as a tight fit around the points <code>pts</code> 
to compute a <strong>representative sample</strong> <code>RS</code> of the point cloud. The value <code>pointSamples</code> 
defines how many points are used for the exhaustive grid search procedure in the next step</li>
<li>
<strong>An exhaustive grid search</strong> (value <code>gridSize</code> specifies the x,y,z dimension of the grid defined by the bounding box <code>A</code>) is performed.
This search is a trivial loop over all grid directions (see Gill Barequet, and Sariel Har-Peled [1]) to find a even smaller bounding box.
For each grid direction <code>g</code> the minimal bounding box of the projected points in direction <code>g</code> is computed. This consists 
of finding the minimal rectangle (axis <code>u</code> and <code>v</code> in world frame) of the projected point cloud in the plane perpendicular to direction <code>g</code>. The minimal bounding box <code>G</code> in direction <code>g</code> can be computed from the basis <code>(u,v,g)</code> and is a candidate for the overall minimzation problem.
Each found minimal bounding box candidate <code>G</code> and its directions <code>(u,v,g)</code> can be used as a starting point for a <strong>second optional optimization loop</strong> (parameter <code>mvbbGridSearchOptLoops</code>, same algorithm as in step 5 but with less points namely <code>RS</code> ).</li>
<li>The final approximation for the mininmal volume bounding box (minimal volume over all computed candiadates) is returned. <img class="emoji" title=":poop:" alt=":poop:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png" height="20" width="20" align="absmiddle">
</li>
</ol>

<hr>

<h2>
<a id="building-and-visualizing-the-tests" class="anchor" href="#building-and-visualizing-the-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building and Visualizing the Tests</h2>

<p>Building and installing the basic tests is done by:</p>

<pre><code>$ cd Build
$ make ApproxMVBBTests
</code></pre>

<p><strong>Note:</strong></p>

<blockquote>
<p>To run the test in high-performance mode (needs lots of ram), which tests also points clouds of 
140 million points and some polygonal statue <code>lucy.txt</code> succesfully you need 
to set the cmake variable <code>ApproxMVBB_TESTS_HIGH_PERFORMANCE</code> to <code>ON</code>
and additionally initialize the submodule <code>additional</code> and unzip the files:</p>

<pre><code>$ cd ApproxMVBB
$ git submodule init
$ git submodule update
$ cd addtional/tests/files; cat Lucy* | tar xz 
</code></pre>

<p>and rebuild the tests. (this will copy the additional files next to the executable)</p>
</blockquote>

<p>Executing the test application <code>cd tests; ./ApproxMVBBTests</code> will then run the following tests:</p>

<ol>
<li>Testing the ConvexHull2D for several point clouds in 2D</li>
<li>Minimal area rectangle tests for several point clouds in 2D</li>
<li>Testing the diameter computation and calculation of the initial bounding box <code>A</code> 
(see <a href="Function%20Parameters%20&amp;%20How%20It%20Works">section</a>)
for point clouds in 3D</li>
<li>Testing the full optimization pipeline to generate an approximation of the minimal volume bounding box</li>
</ol>

<p>The output can be visualized with the <code>ipython notebook</code> <code>/tests/python/PlotTestResults.ipynb</code>:</p>

<pre><code>$ cd Build/tests
$ ipython noteboook
</code></pre>

<p align="center">
<img src="https://github.com/gabyx/ApproxMVBB/wiki/images/ConvexHull.png">
</p>

<hr>

<h2>
<a id="benchmark" class="anchor" href="#benchmark" aria-hidden="true"><span class="octicon octicon-link"></span></a>Benchmark</h2>

<p>Here are some short benchmarks from the tests folder:   </p>

<table>
<thead>
<tr>
<th>Point Cloud</th>
<th align="right"># Points</th>
<th align="right">~ CPU Time <code>approximateMVBB</code>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>Standford Bunny</td>
<td align="right">35'945</td>
<td align="right">0.91 s</td>
</tr>
<tr>
<td>Standford Lucy</td>
<td align="right">14'027'872</td>
<td align="right">1.19 s</td>
</tr>
<tr>
<td>Unit Cube</td>
<td align="right">140'000'000</td>
<td align="right">7.0 s</td>
</tr>
</tbody>
</table>

<p><code>approximateMVBB</code> runs <code>approximateMVBBDiam</code> and performs a grid search afterwards (here 5x5x5=25 directions with  5 optimization runs for each)
It seems to take a long time for 140 million points. The most ineffiecient task is to get a good initial bounding box. This takes the most time as diameter computations are performed in 3d and then all points are projected in the found diameter direction in 3d and another diameter in the projected plane in 2d is computed. Afterwards the point cloud is sampled (not just random points, its done with a grid) and convex hull, minimal rectangle computations are performed over the grid directions. These algorithms could be made faster by exploiting the following things:</p>

<ul>
<li>Use an axis aligned bounding box as the initial bounding box for the grid search (not implemented yet)</li>
<li>Parllelism for the projection -&gt; (CUDA, threads)</li>
</ul>

<hr>

<h2>
<a id="licensing" class="anchor" href="#licensing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Licensing</h2>

<p>This source code is released under MPL 2.0. </p>

<hr>

<h2>
<a id="author-and-acknowledgements" class="anchor" href="#author-and-acknowledgements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Author and Acknowledgements</h2>

<p>ApproxMVBB was written by Gabriel Nützi, with source code from <a href="http://www-sop.inria.fr/members/Gregoire.Malandain/diameter/">Grégoire Malandain &amp; Jean-Daniel Boissonnat</a> 
for the approximation of the diameter of a point cloud.
I was inspired by the work and algorithms of <a href="http://sarielhp.org/papers/00/diameter/">Gill Barequet &amp; Sariel Har-Peled</a> for computing a minimal volume bounding box.
Additionally,  the geometric predicates (orient2d) used in the convex hull algorithm (graham scan) have been taken from the fine work of <a href="http://www.cs.cmu.edu/%7Equake/robust.html">Jonathan Richard Shewchuk</a>.
Special thanks go to my significant other which always had an ear during breakfast for this little project <img class="emoji" title=":kissing_heart:" alt=":kissing_heart:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f618.png" height="20" width="20" align="absmiddle"></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">ApproxMVBB maintained by <a href="https://github.com/gabyx">gabyx</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-57518221-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
