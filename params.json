{"name":"ApproxMVBB","tagline":"Fast algorithms to compute an approximation of the minimal volume oriented bounding box of a point cloud in 3D.","body":"==========\r\nApproxMVBB\r\n==========\r\n\r\n----------------------------------------\r\nFast algorithms to compute an approximation of the minimal volume oriented bounding box of a point cloud in 3D.\r\n----------------------------------------\r\n\r\nComputing the minimal volume oriented bounding box for a given point cloud in 3D is a hard problem in computer science.\r\nExact algorithms are known and of cubic order in the number of points in 3D. A faster exact algorithm is currently not know. However, for lots of applications an approximation of the minimum volume oriented bounding box is acceptable and already accurate enough.  \r\nThis small library can either be built into a shared object library \r\nor directly be included in an existing C++ project. It includes code for computing the ConvexHull in 2D an the minimal area rectangle of a 2D point cloud as well.\r\n\r\n![alt text](https://github.com/gabyx/ApproxMVBB/wiki/images/Bunny.png \"Bunny\") ![alt text](https://github.com/gabyx/ApproxMVBB/wiki/images/Cube.png \"Cube\")\r\n\r\n---------------------------\r\nInstallation & Dependencies\r\n---------------------------\r\nTo build the library, the tests and the example you need the built tool `cmake\r\n<www.cmake.org>`_.\r\nThis library only depends on the matrix library `Eigen\r\n<eigen.tuxfamily.org>`_ at least version 3. Download it and install it on your system!\r\n\r\nDownload the latest ApproxMVBB code::\r\n\r\n    $ git clone https://github.com/gabyx/ApproxMVBB.git ApproxMVBB  \r\n  \r\nMake a build directory and navigate to it::\r\n\r\n    $ mkdir Build\r\n    $ cd Build\r\n\r\nInvoke cmake in the Build directory::\r\n\r\n    $ cmake ../ApproxMVBB\r\n\r\nThe cmake script will find Eigen if you installed it in a system wide folder (e.g ``/usr/local/``)\r\nIn the `CMakeCache.txt` file you can specify what you want to build \r\n( ``ApproxMVBB_BUILD_EXAMPLE, ApproxMVBB_BUILD_LIBRARY, ApproxMVBB_BUILD_TESTS`` )\r\n\r\nTo install the library and the header files at a specific location `/usr/local/include/` run cmake with::\r\n\r\n    $ cmake -DCMAKE_INSTALL_PREFIX=\"/usr/local/include/\" ../ApproxMVBB\r\n\r\nFinally, build and install the project::\r\n\r\n    $ make all   /* can be ApproxMVBB for the library or ApproxMVBBExample or ApproxMVBBTests */\r\n    $ make install\r\n \r\n To build in parallel use the ``-jN`` flag in the `make` commmand, where ``N``denotes the number of parallel threads to use.\r\n \r\n \r\n---------------------------\r\nExample Usage\r\n---------------------------\r\nPlease see the ``example/main.cpp`` in the source directory.\r\nGiven a point cloud with ``n=10000`` points sampled in the unit cube in 3D \r\nwe compute an approximation of the minimum volume bounding volume by the following calls::\r\n```C++\r\n    #include <iostream>\r\n    #include \"ApproxMVBB/ComputeApproxMVBB.hpp\"\r\n\r\n    int  main( int  argc, char  ** argv ){\r\n    \r\n          ApproxMVBB::Matrix3Dyn points(3,10000);\r\n          points.setRandom();\r\n          ApproxMVBB::OOBB oobb = ApproxMVBB::approximateMVBB(points,0.001,500,5,0,5);\r\n          \r\n          return 0;\r\n          \r\n    }\r\n```\r\nThe returned object oriented bounding box ``oobb`` contains the lower ``oobb.m_minPoint`` and upper point ``oobb.m_maxPoint``\r\nin expressed in the coordinate frame K of the bounding box. The bounding box also stores the rotation matrix from the world frame to the object frame K \r\nin form of a quaternion  ``oobb.m_q_KI`` . The rotation matrix ``R_KI`` from frame I to frame K  can be obtained by ``oobb.m_q_KI.matrix()`` (see ``Eigen::Quaternion``). This rotation matrix ``R_KI`` corresponds to a coordinate transformation A_IK which transforms coordinates from frame K to coordinates in frame I. Thereforce, to get the lower point expressed in the coordinate frame I this yields::\r\n\r\n```C++\r\n    ApproxMVBB::Vector3 p = oobb.m_q_IK * oobb.m_minPoint  // A_IK * oobb.m_minPoint \r\n```\r\n\r\n---------------------------\r\nFunction Parameters & How It Works\r\n---------------------------\r\nThe most important function::\r\n```C++\r\n    ApproxMVBB::approximateMVBB(pts, \r\n                                epsilon, \r\n                                pointSamples, \r\n                                gridSize,\r\n                                mvbbDiamOptLoops, \r\n                                gridSearchOptLoops)\r\n```\r\ncomputes an approximation of the minimal volume bounding box in the following steps:\r\n\r\n1. **An approximation of the diameter** (direction which realizes the diameter: ``z`` ) of the points ``pts`` is computed. \r\n   The value ``epsilon`` is the absolut tolarance for \r\n   the approximation of the diameter and has the same units as the points ``pts`` (in the example 0.001 meter)\r\n2. The points are projected into the plane perpendicular to the direction ``z``\r\n3. An approximation of the diameter of the projected points in 2D is computed (direction ``x`` )\r\n4. **The initial approximate bounding box** ``A`` is computed in the orthogonal frame ``[x,y,z]``\r\n5. **An optional optimization loop** is performed (value ``mvbbDiamOptLoops`` specifies how many loops) \r\n   by computing the minimal volume bounding box over a direction ``t`` where the direction ``t`` \r\n   is choosen sequentially from the current optimal bounding box solution.  \r\n5. **The initial bounding box** ``A`` is used as a tight fit around the points ``pts`` \r\n   to compute a **representative sample** of the point cloud. The value ``pointSamples`` \r\n   defines how many points are used for the exhaustive grid search procedure in the next step\r\n6. **An exhaustive grid search** (value ``gridSize`` specifies the x,y,z dimension of the grid defined by the bounding box ``A``) is performed.\r\n   This search is a trivial loop over all grid directions (see Gill Barequet, and Sariel Har-Peled [1]) to find a even smaller bounding box.\r\n   For each grid direction ``g`` the minimal bounding box in this direction is computed. This consists \r\n   of finding the minimal rectangle of the projected 2D point cloud in the plane perpendicular to direction ``g``.\r\n   For each grid direction another **optional optimization loop** (same as in step 5, value ``gridSearchOptLoops`` ) can be \r\n   specified which again optimizes the volume starting from direction ``g``.\r\n7. The final approximation for the mininmal volume bounding box is returned. :poop:\r\n\r\n---------------------------\r\nBuilding and Visualizing the Tests\r\n---------------------------\r\nBuilding and installing the basic tests is done by ::\r\n\r\n    $ cd Build\r\n    $ make ApproxMVBBTests\r\n    \r\n**Note:**\r\nTo run the test in high-performance mode (needs lots of ram), which tests also points clouds of \r\n140 million points and some polygonal statue ``lucy.txt`` succesfully you need \r\nto set the cmake variable ``ApproxMVBB_TESTS_HIGH_PERFORMANCE`` to ``ON``\r\nand additionally initialize the submodule ``AdditionalFiles``\r\nand copy the file ``Lucy.txt`` (~500mb) to the build folder of the tests ``BUILD/tests/``\r\n\r\n\r\nExecuting the test application ``cd tests; ./ApproxMVBBTests`` will then run the following tests:\r\n\r\n1. Testing the ConvexHull2D for several point clouds in 2D\r\n2. Minimal area rectangle tests for several point clouds in 2D\r\n3. Testing the diameter computation and calculation of the initial bounding box ``A`` (see `Function Parameters & How It Works`_)\r\n   for point clouds in 3D\r\n4. Testing the full optimization pipeline to generate an approximation of the minimal volume bounding box\r\n\r\nThe output can be visualized with the ``ipython notebook`` ``PlotTestResults.ipynb``::\r\n\r\n    $ cd Build/tests\r\n    $ ipython noteboook\r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/gabyx/ApproxMVBB/wiki/images/ConvexHull.png\"/>\r\n</p>\r\n\r\n---------------------------\r\nAuthor and Acknowledgements\r\n---------------------------\r\n\r\nApproxMVBB was written by Gabriel Nützi, with source code from Grégoire Malandain & Jean-Daniel Boissonnat \r\n(for the approximation of the diameter of a point cloud)\r\nand Gill Barequet & Sariel Har-Peled (for the inspiration of the algorithms to compute a minimal volume bounding box)\r\n(reference to come!)\r\n\r\n","google":"UA-57518221-1","note":"Don't delete this file! It's used internally to help with page regeneration."}